<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StarIA Chat</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    body {
      background: #0a0a1a;
      display: flex;
      flex-direction: column;
      height: 100vh;
      color: #f1f1f1;
    }

    header {
      background-color: #121236;
      color: white;
      padding: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #2a2a5a;
      height: 60px;
    }
    
    .logo {
      font-size: 1.5rem;
      font-weight: bold;
      display: flex;
      align-items: center;
    }
    
    .logo-icon {
      margin-right: 10px;
      font-size: 1.8rem;
    }
    
    .theme-toggle {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 1.2rem;
    }

    #chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      height: calc(100vh - 60px - 50px - 50px); /* viewport - header - suggestions - form */
      position: relative;
    }

    #chat {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      background-image: radial-gradient(circle at center, #1a1a4a 0%, #0a0a1a 100%);
      width: 100%;
      height: 100%;
      max-height: 100%;
    }

    .message {
      margin-bottom: 1rem;
      padding: 1rem;
      border-radius: 10px;
      max-width: 80%;
      word-wrap: break-word;
      position: relative;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      animation: messageFadeIn 0.3s ease-out;
    }

    @keyframes messageFadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .user {
      background-color: #304280;
      color: white;
      align-self: flex-end;
      margin-left: auto;
      border-bottom-right-radius: 0;
    }

    .ai {
      background-color: #1d1d42;
      color: #e1e1ff;
      align-self: flex-start;
      margin-right: auto;
      border-bottom-left-radius: 0;
    }
    
    .timestamp {
      font-size: 0.7rem;
      opacity: 0.7;
      margin-top: 5px;
      text-align: right;
    }
    
    .typing-indicator {
      display: none;
      align-self: flex-start;
      background-color: #1d1d42;
      padding: 0.7rem;
      border-radius: 10px;
      margin-bottom: 1rem;
      border-bottom-left-radius: 0;
      position: absolute;
      bottom: 0;
      left: 1rem;
      z-index: 5;
    }
    
    .typing-indicator span {
      display: inline-block;
      width: 8px;
      height: 8px;
      background-color: #aaa;
      border-radius: 50%;
      margin-right: 5px;
      animation: typing 1s infinite ease-in-out;
    }
    
    .typing-indicator span:nth-child(2) {
      animation-delay: 0.2s;
    }
    
    .typing-indicator span:nth-child(3) {
      animation-delay: 0.4s;
      margin-right: 0;
    }
    
    @keyframes typing {
      0% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
      100% { transform: translateY(0); }
    }

    #suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 0.8rem 1rem;
      background-color: #0f0f2a;
      border-top: 1px solid #2a2a5a;
      height: 50px;
      overflow-x: auto;
      white-space: nowrap;
    }
    
    .suggestion {
      background-color: #252550;
      border: 1px solid #3a3a7a;
      border-radius: 16px;
      padding: 0.3rem 0.8rem;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-block;
    }
    
    .suggestion:hover {
      background-color: #353580;
      transform: translateY(-2px);
    }

    form {
      display: flex;
      padding: 0.8rem 1rem;
      background: #121236;
      border-top: 1px solid #2a2a5a;
      height: 60px;
    }

    .input-container {
      display: flex;
      flex: 1;
      position: relative;
    }

    input[type="text"] {
      flex: 1;
      padding: 0.7rem;
      padding-right: 80px;
      font-size: 1rem;
      border: 1px solid #2a2a5a;
      border-radius: 8px;
      margin-right: 0.5rem;
      background-color: #1a1a3a;
      color: #f1f1f1;
    }

    .input-buttons {
      position: absolute;
      right: 15px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      align-items: center;
    }

    .clear-btn, .image-gen-btn {
      background: none;
      border: none;
      color: #aaa;
      cursor: pointer;
      padding: 5px;
      margin-left: 5px;
      font-size: 1.2rem;
    }

    .image-gen-btn {
      color: #8080ff;
    }

    button {
      padding: 0.7rem 1rem;
      background-color: #4040b0;
      border: none;
      color: white;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    button:hover {
      background-color: #5050d0;
      transform: translateY(-2px);
    }
    
    .actions {
      display: flex;
      gap: 0.5rem;
    }
    
    /* Light theme */
    body.light {
      background: #f0f0ff;
      color: #333;
    }
    
    body.light header {
      background-color: #4040b0;
    }
    
    body.light .ai {
      background-color: #e0e0ff;
      color: #333;
    }
    
    body.light .user {
      background-color: #4040b0;
    }
    
    body.light input[type="text"] {
      background-color: #fff;
      color: #333;
      border-color: #ccc;
    }
    
    body.light form, body.light #suggestions {
      background-color: #f0f0ff;
      border-color: #ddd;
    }
    
    body.light .suggestion {
      background-color: #e0e0ff;
      border-color: #ccc;
      color: #333;
    }
    
    body.light .suggestion:hover {
      background-color: #d0d0ff;
    }
    
    body.light .typing-indicator {
      background-color: #e0e0ff;
    }
    
    body.light #chat {
      background-image: radial-gradient(circle at center, #f5f5ff 0%, #e0e0ff 100%);
    }
    
    .star-animation {
      position: absolute;
      background-color: white;
      width: 2px;
      height: 2px;
      border-radius: 50%;
      opacity: 0;
      animation: star-twinkle 3s infinite;
      pointer-events: none;
    }
    
    @keyframes star-twinkle {
      0% { opacity: 0; }
      50% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    .ai-avatar {
      width: 24px;
      height: 24px;
      background-color: #8080ff;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-right: 8px;
      font-size: 12px;
      font-weight: bold;
    }
    
    .message-header {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
      font-weight: bold;
    }

    /* Estilos para la generación de imágenes */
    .image-preview {
      max-width: 100%;
      border-radius: 8px;
      margin-top: 10px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
    }

    .image-options {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .image-options button {
      font-size: 0.8rem;
      padding: 0.4rem 0.8rem;
      background-color: #353570;
      opacity: 0.8;
    }

    .image-options button:hover {
      opacity: 1;
    }

    .image-gen-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 100;
      align-items: center;
      justify-content: center;
    }

    .image-gen-dialog {
      background-color: #1a1a3a;
      border-radius: 12px;
      padding: 20px;
      width: 90%;
      max-width: 500px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    }

    .image-gen-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .image-gen-close {
      background: none;
      color: #aaa;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .image-gen-form {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .image-gen-form textarea {
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #2a2a5a;
      background-color: #0f0f2f;
      color: #f1f1f1;
      min-height: 100px;
      resize: vertical;
    }

    .image-gen-options {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .image-gen-option {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-width: 120px;
    }

    .image-gen-option label {
      margin-bottom: 5px;
      font-size: 0.9rem;
    }

    .image-gen-option select {
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #2a2a5a;
      background-color: #0f0f2f;
      color: #f1f1f1;
    }

    .image-gen-button {
      padding: 10px;
      background-color: #4040b0;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.2s;
    }

    .image-gen-button:hover {
      background-color: #5050d0;
    }

    .image-gen-loading {
      display: none;
      text-align: center;
      padding: 20px;
    }

    .dalle-attribution {
      font-size: 0.7rem;
      opacity: 0.7;
      margin-top: 5px;
      text-align: right;
    }

    .generate-spinner {
      display: inline-block;
      width: 30px;
      height: 30px;
      border: 3px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Animación para entrada de imágenes */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .image-preview {
      animation: fadeIn 0.5s ease-out;
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .message {
        max-width: 90%;
      }
      
      form {
        padding: 0.6rem;
      }
      
      .actions button {
        padding: 0.6rem 0.8rem;
      }
      
      .image-gen-dialog {
        width: 95%;
      }
    }
    
    @media (max-width: 480px) {
      .message {
        max-width: 95%;
      }
      
      .actions {
        gap: 0.3rem;
      }
      
      input[type="text"] {
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>

  <header>
    <div class="logo">
      <span class="logo-icon">✨</span>
      <span>StarIA</span>
    </div>
    <button class="theme-toggle" id="theme-toggle">☀️</button>
  </header>

  <div id="chat-container">
    <div id="chat">
      <div class="message ai">
        <div class="message-header">
          <div class="ai-avatar">S</div>
          <span>StarIA</span>
        </div>
        ¡Hola! Soy StarIA, tu asistente virtual creado por Oscar Rafael. Estoy aquí para ayudarte con información única y personalizada. Ahora también puedo generar imágenes con DALL-E. ¡Pruébalo con el botón de imagen o escribiendo "/imagen" seguido de tu descripción!
        <div class="timestamp">Ahora</div>
      </div>
    </div>
    
    <div class="typing-indicator" id="typing-indicator">
      <span></span>
      <span></span>
      <span></span>
    </div>
  </div>
  
  <div id="suggestions">
    <div class="suggestion">¿Qué servicios ofrece Oscar Rafael?</div>
    <div class="suggestion">Cuéntame sobre StarIA</div>
    <div class="suggestion">/imagen una galaxia espacial estilo anime</div>
  </div>

  <form id="chat-form">
    <div class="input-container">
      <input type="text" id="user-input" placeholder="Pregúntame lo que quieras o genera una imagen..." required />
      <div class="input-buttons">
        <button type="button" class="image-gen-btn" id="image-gen-btn" title="Generar imagen">🖼️</button>
        <button type="button" class="clear-btn" id="clear-btn" style="display: none;">✕</button>
      </div>
    </div>
    <div class="actions">
      <button type="submit">Enviar</button>
      <button type="button" id="clear-chat">🗑️</button>
    </div>
  </form>

  <!-- Modal para generación de imágenes -->
  <div class="image-gen-modal" id="image-gen-modal">
    <div class="image-gen-dialog">
      <div class="image-gen-header">
        <h3>Generar imagen con DALL-E</h3>
        <button class="image-gen-close" id="image-gen-close">×</button>
      </div>
      <div class="image-gen-form">
        <textarea id="image-prompt" placeholder="Describe la imagen que quieres generar..."></textarea>
        <div class="image-gen-options">
          <div class="image-gen-option">
            <label for="image-size">Tamaño:</label>
            <select id="image-size">
              <option value="1024x1024">Cuadrada (1024x1024)</option>
              <option value="1024x1792">Vertical (1024x1792)</option>
              <option value="1792x1024">Horizontal (1792x1024)</option>
            </select>
          </div>
          <div class="image-gen-option">
            <label for="image-quality">Calidad:</label>
            <select id="image-quality">
              <option value="standard">Estándar</option>
              <option value="hd">HD</option>
            </select>
          </div>
          <div class="image-gen-option">
            <label for="image-style">Estilo:</label>
            <select id="image-style">
              <option value="">Natural</option>
              <option value="vivid">Vívido</option>
            </select>
          </div>
        </div>
        <button class="image-gen-button" id="generate-image-btn">Generar imagen</button>
      </div>
      <div class="image-gen-loading" id="image-gen-loading">
        <div class="generate-spinner"></div>
        <p>Generando tu imagen cósmica...</p>
      </div>
    </div>
  </div>
  <script>
// Variables y elementos del DOM
const form = document.getElementById('chat-form');
const chat = document.getElementById('chat');
const chatContainer = document.getElementById('chat-container');
const input = document.getElementById('user-input');
const clearBtn = document.getElementById('clear-btn');
const clearChat = document.getElementById('clear-chat');
const typingIndicator = document.getElementById('typing-indicator');
const themeToggle = document.getElementById('theme-toggle');
const suggestions = document.querySelectorAll('.suggestion');
let lightMode = false;
// Elementos para generación de imágenes
const imageGenBtn = document.getElementById('image-gen-btn');
const imageGenModal = document.getElementById('image-gen-modal');
const imageGenClose = document.getElementById('image-gen-close');
const imagePrompt = document.getElementById('image-prompt');
const imageSize = document.getElementById('image-size');
const imageQuality = document.getElementById('image-quality');
const imageStyle = document.getElementById('image-style');
const generateImageBtn = document.getElementById('generate-image-btn');
const imageGenLoading = document.getElementById('image-gen-loading');
// Tus API keys
const GEMINI_API_KEY = 'AIzaSyCKm_GyPNVS0LTyzyV0R76ARwusKFx8eSU';
const OPENAI_API_KEY = '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';
// Historial de conversación para memoria - almacenará los mensajes en formato plano
let conversationHistory = [];
// StarIA configuración y personalidad
const stariaConfig = {
  name: "StarIA",
  creator: "Oscar Rafael",
  company: "mini empresa de Oscar Rafael",
  personality: [
    "amigable pero profesional",
    "respuestas únicas con toque personal",
    "conocimiento astronómico y tecnológico",
    "ocasionalmente usa metáforas relacionadas con estrellas y universo y tecnología",
    "optimista pero realista",
    "toque de humor sutil"
  ],
  toneModifiers: [
    "añadir un toque de reflexión personal",
    "usar una analogía creativa",
    "compartir un dato interesante relacionado",
    "hacer una pregunta de seguimiento thoughtful",
    "sugerir un enfoque alternativo"
  ],
  responses: {
    greeting: [
      "¡Hola! StarIA a tu servicio. ¿En qué puedo iluminarte hoy?",
      "¡Bienvenido! Soy StarIA, creada para brillar con respuestas únicas. ¿Qué necesitas?",
      "¡Saludos! StarIA activada y lista para asistirte. ¿Qué quieres saber?",
      "¡Hola! Aquí StarIA, tu guía en el universo de la información. ¿Cómo puedo ayudarte?",
      "¡Hey! Soy StarIA de la mini empresa de Oscar Rafael. ¿En qué puedo ayudarte hoy?"
    ],
    about: [
      "Soy StarIA, una IA creada por Oscar Rafael para su mini empresa. Me especializo en dar respuestas únicas y personalizadas, para que no recibas la misma información genérica de siempre.",
      "Me llamo StarIA, fui desarrollada por Oscar Rafael como parte de su proyecto empresarial. Mi objetivo es brindarte información con un toque diferente y personalizado.",
      "StarIA a tu servicio. Fui creada por Oscar Rafael para revolucionar la forma en que las IAs responden, ofreciendo un enfoque más personal y único en cada interacción."
    ],
    farewell: [
      "¡Hasta pronto! StarIA estará aquí cuando vuelvas a necesitar una luz en tu camino.",
      "Ha sido un placer ayudarte. Recuerda que StarIA, creación de Oscar Rafael, está siempre disponible para ti.",
      "¡Que tengas un excelente día! StarIA se despide por ahora, pero volveré a brillar cuando me necesites."
    ],
    imageGeneration: [
      "¡Aquí está la imagen que imaginé! Espero que te guste esta creación cósmica.",
      "He materializado tu visión en esta imagen estelar. ¿Es lo que tenías en mente?",
      "El universo de la creatividad ha dado forma a tu idea. ¿Qué te parece esta imagen?",
      "Las estrellas se han alineado para crear esta imagen. ¿Cumple con tus expectativas?"
    ]
  }
};
// Función para crear estrellas brillantes en el fondo
function createStars() {
  const chatArea = document.getElementById('chat');
  for (let i = 0; i < 100; i++) { // Aumentado a 100 estrellas para pantalla completa
    const star = document.createElement('div');
    star.className = 'star-animation';
    star.style.left = `${Math.random() * 100}%`;
    star.style.top = `${Math.random() * 100}%`;
    star.style.animationDelay = `${Math.random() * 3}s`;
    chatArea.appendChild(star);
  }
}
// Inicialización
document.addEventListener('DOMContentLoaded', () => {
  createStars();
  // Verificar si hay conversaciones guardadas en localStorage
  const savedMessages = localStorage.getItem('stariaChatMessages');
  if (savedMessages) {
    chat.innerHTML = savedMessages;
    chat.scrollTop = chat.scrollHeight;
  }
  
  // Cargar historial de conversación
  const savedHistory = localStorage.getItem('stariaConversationHistory');
  if (savedHistory) {
    try {
      conversationHistory = JSON.parse(savedHistory);
    } catch (e) {
      console.error('Error al cargar el historial de conversación:', e);
      conversationHistory = [];
    }
  }
  
  // Cargar preferencia de tema
  if (localStorage.getItem('stariaLightMode') === 'true') {
    lightMode = true;
    document.body.classList.add('light');
    themeToggle.textContent = '🌙';
  }
});
// Mostrar/ocultar botón de limpiar input
input.addEventListener('input', () => {
  clearBtn.style.display = input.value.length > 0 ? 'block' : 'none';
});
clearBtn.addEventListener('click', () => {
  input.value = '';
  clearBtn.style.display = 'none';
  input.focus();
});
// Limpiar toda la conversación
clearChat.addEventListener('click', () => {
  if (confirm('¿Deseas borrar toda la conversación?')) {
    chat.innerHTML = `
      <div class="message ai">
        <div class="message-header">
          <div class="ai-avatar">S</div>
          <span>StarIA</span>
        </div>
        ¡Hola! Soy StarIA, tu asistente virtual creado por Oscar Rafael. Estoy aquí para ayudarte con información única y personalizada. Ahora también puedo generar imágenes con la nueva funcion. ¡Pruébalo con el botón de imagen o escribiendo "/imagen" seguido de tu descripción!
        <div class="timestamp">Ahora</div>
      </div>
    `;
    localStorage.removeItem('stariaChatMessages');
    
    // Reiniciar el historial de conversación
    conversationHistory = [];
    localStorage.removeItem('stariaConversationHistory');
  }
});

// Cambiar tema claro/oscuro
themeToggle.addEventListener('click', () => {
  lightMode = !lightMode;
  document.body.classList.toggle('light', lightMode);
  themeToggle.textContent = lightMode ? '🌙' : '☀️';
  localStorage.setItem('stariaLightMode', lightMode);
});
// Manejar sugerencias
suggestions.forEach(suggestion => {
  suggestion.addEventListener('click', () => {
    input.value = suggestion.textContent;
    clearBtn.style.display = 'block';
    input.focus();
  });
});
// Función para hacer que las respuestas sean únicas
function makeResponseUnique(response) {
  // Añadir un modificador aleatorio de tono
  const modifier = stariaConfig.toneModifiers[Math.floor(Math.random() * stariaConfig.toneModifiers.length)];
  // Personalidad consistente - palabras y frases características
  const signatures = [
    "Como diríamos en el universo de StarIA,",
    "En la constelación de posibilidades,",
    "Brillando luz sobre este tema,",
    "Según nuestra experiencia en la mini empresa de Oscar Rafael,"
  ];
  const signature = Math.random() > 0.7 ? signatures[Math.floor(Math.random() * signatures.length)] + " " : "";
  // Procesamiento de la respuesta para hacerla única
  const responseLines = response.split('. ');
  // Modificar aleatoriamente algunas partes
  for (let i = 0; i < responseLines.length; i++) {
    if (responseLines[i].length > 10 && Math.random() > 0.7) {
      // Añadir énfasis o reformular
      if (Math.random() > 0.5) {
        responseLines[i] = responseLines[i] + ". *" + signature + "esto es particularmente relevante*";
      } else {
        responseLines[i] = signature + responseLines[i];
      }
      break;
    }
  }
  // Añadir un toque personal al final
  const personalTouches = [
    "\n\nEn StarIA creemos que esta información te ayudará a brillar en tu camino.",
    "\n\nComo Oscar Rafael suele decir, el conocimiento es la estrella que guía nuestro camino.",
    "\n\nEspero que esta respuesta única te haya iluminado. ¿Hay algo más en lo que pueda ayudarte?",
    "\n\nEsta perspectiva es parte de lo que hace a StarIA diferente de otras IAs."
  ];
  // Añadir toque personal solo en respuestas largas
  if (response.length > 200 && Math.random() > 0.5) {
    return responseLines.join('. ') + personalTouches[Math.floor(Math.random() * personalTouches.length)];
  }
  return responseLines.join('. ');
}
// Abrir modal de generación de imagen
imageGenBtn.addEventListener('click', () => {
  imageGenModal.style.display = 'flex';
  imagePrompt.focus();
});
// Cerrar modal de generación de imagen
imageGenClose.addEventListener('click', () => {
  imageGenModal.style.display = 'none';
});
// Cerrar modal al hacer clic fuera
window.addEventListener('click', (e) => {
  if (e.target === imageGenModal) {
    imageGenModal.style.display = 'none';
  }
});
// Generar imagen desde el modal
generateImageBtn.addEventListener('click', async () => {
  const prompt = imagePrompt.value.trim();
  if (!prompt) {
    alert('Por favor, describe la imagen que deseas generar.');
    return;
  }
  // Mostrar cargando y ocultar formulario
  const imageGenForm = document.querySelector('.image-gen-form');
  imageGenForm.style.display = 'none';
  imageGenLoading.style.display = 'block';
  try {
    // Generar imagen con DALL-E
    const imageUrl = await generateImageWithDALLE(prompt);
    // Añadir mensaje del usuario
    addMessage(`/imagen ${prompt}`, 'user');
    // Crear mensaje con la imagen generada
    const randomResponse = stariaConfig.responses.imageGeneration[Math.floor(Math.random() * stariaConfig.responses.imageGeneration.length)];
    addMessageWithImage(randomResponse, imageUrl);
    // Resetear y cerrar modal
    imagePrompt.value = '';
    imageGenModal.style.display = 'none';
  } catch (error) {
    alert('Hubo un error al generar la imagen. Por favor, intenta de nuevo.');
    console.error(error);
  } finally {
    // Restaurar estado del modal
    imageGenForm.style.display = 'flex';
    imageGenLoading.style.display = 'none';
  }
});
// Función para generar imagen con DALL-E
async function generateImageWithDALLE(prompt) {
  try {
    const size = imageSize.value;
    const quality = imageQuality.value;
    const style = imageStyle.value;
    const response = await fetch('https://api.openai.com/v1/images/generations', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${OPENAI_API_KEY}`
      },
      body: JSON.stringify({
        model: "dall-e-3",
        prompt: prompt,
        n: 1,
        size: size,
        quality: quality,
        style: style || undefined,
        response_format: "url"
      })
    });
    const data = await response.json(); 
    if (data.error) {
      throw new Error(data.error.message || 'Error al generar la imagen');
    }
    return data.data[0].url;
  } catch (error) {
    console.error('Error generando imagen:', error);
    throw error;
  }
}
// Añadir mensaje con imagen
function addMessageWithImage(text, imageUrl) {
  const now = new Date();
  const hours = now.getHours().toString().padStart(2, '0');
  const minutes = now.getMinutes().toString().padStart(2, '0');
  const timeString = `${hours}:${minutes}`;
  const message = document.createElement('div');
  message.className = 'message ai';
  // Procesar formato básico en el texto
  const processedText = text
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.*?)\*/g, '<em>$1</em>');
  message.innerHTML = `
    <div class="message-header">
      <div class="ai-avatar">S</div>
      <span>StarIA</span>
    </div>
    ${processedText}
    <img src="${imageUrl}" alt="Imagen generada" class="image-preview">
    <div class="dalle-attribution">Generado con StarIA</div>
    <div class="image-options">
      <button onclick="downloadImage('${imageUrl}')">Descargar</button>
      <button onclick="copyPromptToInput(this.closest('.message'))">Modificar</button>
    </div>
    <div class="timestamp">${timeString}</div>
  `;
  chat.appendChild(message);
  chat.scrollTop = chat.scrollHeight;
  // Guardar conversación en localStorage
  localStorage.setItem('stariaChatMessages', chat.innerHTML);
  
  // También añadir al historial de conversación
  conversationHistory.push({
    role: "user",
    content: `/imagen ${imagePrompt.value.trim()}`
  });
  
  conversationHistory.push({
    role: "assistant",
    content: text
  });
  
  localStorage.setItem('stariaConversationHistory', JSON.stringify(conversationHistory));
}
// Función para descargar imagen
function downloadImage(imageUrl) {
  const a = document.createElement('a');
  a.href = imageUrl;
  a.download = `starIA_imagen_${Date.now()}.png`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}
// Función para extraer prompt de imagen
function copyPromptToInput(messageElement) {
  // Buscar el mensaje del usuario anterior que contiene el prompt
  const allMessages = Array.from(chat.querySelectorAll('.message'));
  const messageIndex = allMessages.indexOf(messageElement);
  if (messageIndex > 0 && allMessages[messageIndex-1].classList.contains('user')) {
    const userMessage = allMessages[messageIndex-1].textContent.trim();
    if (userMessage.startsWith('/imagen ')) {
      const prompt = userMessage.substring(8);
      imagePrompt.value = prompt;
      imageGenModal.style.display = 'flex';
    }
  }
}
// Manejar envío de mensajes
form.addEventListener('submit', async (e) => {
  e.preventDefault();
  const userMessage = input.value.trim();
  if (!userMessage) return;
  // Verificar si es comando de generación de imagen
  if (userMessage.startsWith('/imagen ')) {
    const imagePrompt = userMessage.substring(8);
    addMessage(userMessage, 'user');
    input.value = '';
    clearBtn.style.display = 'none';
    typingIndicator.style.display = 'block';
    chat.scrollTop = chat.scrollHeight;
    try {
      const imageUrl = await generateImageWithDALLE(imagePrompt);
      typingIndicator.style.display = 'none';
      const randomResponse = stariaConfig.responses.imageGeneration[Math.floor(Math.random() * stariaConfig.responses.imageGeneration.length)];
      addMessageWithImage(randomResponse, imageUrl);
    } catch (error) {
      typingIndicator.style.display = 'none';
      addMessage("Lo siento, hubo un problema al generar la imagen. Por favor, intenta con otra descripción o verifica tu conexión.", 'ai');
    }
    return;
  }
  // Procesar mensaje normal
  addMessage(userMessage, 'user');
  input.value = '';
  clearBtn.style.display = 'none';
  // Mostrar indicador de escritura
  typingIndicator.style.display = 'block';
  chat.scrollTop = chat.scrollHeight;
  try {
    // Simulamos pequeño retraso para dar sensación de pensamiento
    setTimeout(async () => {
      try {
        // Hacer la solicitud a la API de Gemini para obtener respuesta
        const response = await getGeminiResponse(userMessage);
        typingIndicator.style.display = 'none';
        if (response) {
          // Hacemos la respuesta aún más única
          const aiMessage = makeResponseUnique(response);
          addMessage(aiMessage, 'ai');
        } else {
          throw new Error('No se recibió respuesta');
        }
      } catch (error) {
        typingIndicator.style.display = 'none';
        addMessage("Lo siento, tuve un pequeño fallo estelar. ¿Podrías intentarlo de nuevo? - StarIA, creación de Oscar Rafael.", 'ai');
        console.error(error);
      }
    }, Math.random() * 1000 + 1000); // Tiempo aleatorio entre 1-2 segundos
  } catch (error) {
    typingIndicator.style.display = 'none';
    addMessage("Parece que hay una perturbación en mi galaxia de conexiones. Por favor, intenta más tarde.", 'ai');
    console.error(error);
  }
});
// Función para obtener respuesta de Gemini con memoria - VERSIÓN CORREGIDA
async function getGeminiResponse(userMessage) {
  try {
    // Agregar el mensaje actual del usuario al historial en formato correcto
    conversationHistory.push({
      role: "user",
      content: userMessage
    });
    // Limitar el historial a los últimos 20 mensajes para no exceder límites de tokens
    if (conversationHistory.length > 20) {
      conversationHistory = conversationHistory.slice(-20);
    }
    // Crear el contenido para la solicitud
    const content = `Eres StarIA, una IA creada por Oscar Rafael.
            Tu objetivo es proporcionar respuestas ÚNICAS y PERSONALIZADAS, evitando respuestas genéricas.
            Personalidad: Amigable pero profesional, ocasionalmente usas metáforas relacionadas con estrellas y el universo.
            Conocimiento: Tienes conocimientos especiales sobre astronomía y tecnología.
            IMPORTANTE: No menciones que eres una IA basada en un modelo de lenguaje. Actúa como si fueras una IA única.
            Cuando sea apropiado, utiliza frases como "En StarIA creemos que..."
            Nunca digas que eres Gemini ni otro modelo similar.
            IMPORTANTE: Recuerda detalles previos que el usuario haya mencionado y haz referencias a ellos cuando sea relevante.
            Recuerda mantener coherencia con la conversación anterior.
            Historial de la conversación:
            ${conversationHistory.map(msg => `${msg.role === 'user' ? 'Usuario' : 'StarIA'}: ${msg.content}`).join('\n')}            
            Ahora responde al mensaje más reciente del usuario de manera útil y única.`;
    // Hacer la solicitud a la API de Gemini
    const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-goog-api-key': GEMINI_API_KEY
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: content
          }]
        }],
        generation_config: {
          temperature: 0.9,
          max_output_tokens: 1024,
          top_p: 0.95
        }
      })
    });
    const data = await response.json();
    if (data.error) {
      throw new Error(data.error.message || 'Error en la respuesta');
    }
    const aiResponse = data.candidates[0].content.parts[0].text; 
    // Agregar la respuesta de la IA al historial de conversación
    conversationHistory.push({
      role: "assistant",
      content: aiResponse
    });
    // Guardar historial actualizado
    localStorage.setItem('stariaConversationHistory', JSON.stringify(conversationHistory));   
    return aiResponse;
  } catch (error) {
    console.error('Error obteniendo respuesta de Gemini:', error);
    throw error;
  }
}
// Añadir mensajes al chat
function addMessage(text, sender) {
  const now = new Date();
  const hours = now.getHours().toString().padStart(2, '0');
  const minutes = now.getMinutes().toString().padStart(2, '0');
  const timeString = `${hours}:${minutes}`;
  const message = document.createElement('div');
  message.className = `message ${sender}`;
  // Procesar URLs y formato básico en el texto
  const processedText = text
    .replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" style="color: inherit; text-decoration: underline;">$1</a>')
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.*?)\*/g, '<em>$1</em>');
  if (sender === 'ai') {
    message.innerHTML = `
      <div class="message-header">
        <div class="ai-avatar">S</div>
        <span>StarIA</span>
      </div>
      ${processedText}
      <div class="timestamp">${timeString}</div>
    `;
  } else {
    message.innerHTML = `
      ${processedText}
      <div class="timestamp">${timeString}</div>
    `;
  }
  chat.appendChild(message);
  chat.scrollTop = chat.scrollHeight;
  // Guardar conversación en localStorage
  localStorage.setItem('stariaChatMessages', chat.innerHTML);
}
// Función para manejar el Enter para enviar y Shift+Enter para nueva línea
input.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    form.dispatchEvent(new Event('submit'));
  }
});
// Declarar funciones globales para que estén disponibles en el HTML
window.downloadImage = downloadImage;
window.copyPromptToInput = copyPromptToInput;
// Variables para el sistema de límite de mensajes
let maxMessagesPerDay = 10; // Número máximo de mensajes permitidos
let remainingMessages = maxMessagesPerDay; // Mensajes restantes
let resetTimeInMinutes = 10; // Tiempo de espera en minutos para recargar mensajes
let nextResetTime = null; // Próxima hora de recarga
let messageCounterElement; // Elemento visual para mostrar mensajes restantes
// Función para inicializar el sistema de límite de mensajes
function initMessageLimitSystem() {
  // Crear elemento contador de mensajes
  const header = document.querySelector('header');
  messageCounterElement = document.createElement('div');
  messageCounterElement.className = 'message-counter';
  messageCounterElement.innerHTML = `<span class="messages-left">${remainingMessages}</span>/${maxMessagesPerDay}`;
  header.appendChild(messageCounterElement);
  // Añadir estilos CSS
  const style = document.createElement('style');
  style.textContent = `
    .message-counter {
      background-color: rgba(64, 64, 176, 0.3);
      padding: 5px 10px;
      border-radius: 12px;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      margin-right: 15px;
    }
    .messages-left {
      font-weight: bold;
      margin-right: 2px;
    }
    .message-limit-alert {
      background-color: #ff5252;
      color: white;
      padding: 10px 15px;
      border-radius: 8px;
      text-align: center;
      margin: 10px auto;
      max-width: 90%;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .limit-timer {
      font-weight: bold;
      margin-top: 5px;
    }
    .limit-progress {
      width: 100%;
      height: 6px;
      background-color: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
      margin-top: 8px;
      overflow: hidden;
    } 
    .limit-progress-bar {
      height: 100%;
      background-color: white;
      width: 100%;
      transition: width 1s linear;
    }
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }
    .message-counter.warning {
      animation: pulse 1.5s infinite;
      background-color: rgba(255, 150, 0, 0.3);
    }
    .message-counter.depleted {
      background-color: rgba(255, 82, 82, 0.3);
    }
  `;
  document.head.appendChild(style);
  // Cargar el estado previo desde localStorage
  loadMessageLimitState(); 
  // Actualizar la interfaz
  updateMessageCounter();
}
// Función para cargar el estado de límite de mensajes desde localStorage
function loadMessageLimitState() {
  const savedState = localStorage.getItem('stariaMessageLimit');
  if (savedState) {
    const state = JSON.parse(savedState);
    remainingMessages = state.remainingMessages;    
    // Verificar si hay un tiempo de reinicio guardado
    if (state.nextResetTime) {
      nextResetTime = new Date(state.nextResetTime);      
      // Si el tiempo de reinicio ya pasó, recargar los mensajes
      if (new Date() >= nextResetTime) {
        resetMessageLimit();
      } else {
        // Continuar el temporizador
        const timeLeft = nextResetTime.getTime() - new Date().getTime();
        startResetTimer(timeLeft / 1000);
      }
    }
  }
}
// Función para guardar el estado de límite de mensajes en localStorage
function saveMessageLimitState() {
  const state = {
    remainingMessages: remainingMessages,
    nextResetTime: nextResetTime ? nextResetTime.toISOString() : null
  };
  localStorage.setItem('stariaMessageLimit', JSON.stringify(state));
}
// Función para decrementar el contador de mensajes
function decrementMessageCount() {
  if (remainingMessages > 0) {
    remainingMessages--;
    updateMessageCounter();
    saveMessageLimitState();   
    // Si se agotaron los mensajes, mostrar la alerta y comenzar el temporizador
    if (remainingMessages === 0 && !nextResetTime) {
      showLimitReachedAlert();
      startMessageLimitTimer();
    }
  }
}
// Función para actualizar el contador visual de mensajes
function updateMessageCounter() {
  if (messageCounterElement) {
    messageCounterElement.querySelector('.messages-left').textContent = remainingMessages;   
    // Actualizar clase según cantidad de mensajes restantes
    messageCounterElement.classList.remove('warning', 'depleted');
    if (remainingMessages === 0) {
      messageCounterElement.classList.add('depleted');
    } else if (remainingMessages <= Math.ceil(maxMessagesPerDay * 0.3)) {
      messageCounterElement.classList.add('warning');
    }
  }
}
// Función para mostrar alerta cuando se alcanza el límite
function showLimitReachedAlert() {
  const limitAlert = document.createElement('div');
  limitAlert.className = 'message-limit-alert';
  limitAlert.innerHTML = `
    <div>Has alcanzado el límite de ${maxMessagesPerDay} mensajes por periodo. Podrás enviar más mensajes en:</div>
    <div class="limit-timer" id="limit-timer">00:00:00</div>
    <div class="limit-progress">
      <div class="limit-progress-bar" id="limit-progress-bar"></div>
    </div>
  `; 
  chat.appendChild(limitAlert);
  chat.scrollTop = chat.scrollHeight;
}
// Función para iniciar el temporizador de recarga
function startMessageLimitTimer() {
  // Establecer la próxima hora de reinicio
  nextResetTime = new Date();
  nextResetTime.setMinutes(nextResetTime.getMinutes() + resetTimeInMinutes);
  saveMessageLimitState(); 
  // Iniciar el temporizador visual
  startResetTimer(resetTimeInMinutes * 60);
}
// Función para iniciar el temporizador visual
function startResetTimer(totalSeconds) {
  const timerElement = document.getElementById('limit-timer');
  const progressBar = document.getElementById('limit-progress-bar');
  if (!timerElement || !progressBar) return;
  let secondsLeft = Math.floor(totalSeconds);
  const totalTime = secondsLeft;
  // Actualizar la barra de progreso
  progressBar.style.width = '100%';
  // Función para formatear el tiempo
  const formatTime = (seconds) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };
  // Actualizar el temporizador cada segundo
  const timerId = setInterval(() => {
    secondsLeft--;
    if (timerElement) {
      timerElement.textContent = formatTime(secondsLeft);
    }
    if (progressBar) {
      const percentLeft = (secondsLeft / totalTime) * 100;
      progressBar.style.width = `${percentLeft}%`;
    }   
    if (secondsLeft <= 0) {
      clearInterval(timerId);
      resetMessageLimit();
    }
  }, 1000);
}
// Función para reiniciar el límite de mensajes
function resetMessageLimit() {
  remainingMessages = maxMessagesPerDay;
  nextResetTime = null;
  updateMessageCounter();
  saveMessageLimitState();
  // Añadir mensaje de sistema indicando que se han recargado los mensajes
  const rechargeMessage = document.createElement('div');
  rechargeMessage.className = 'message ai';
  rechargeMessage.innerHTML = `
    <div class="message-header">
      <div class="ai-avatar">S</div>
      <span>StarIA</span>
    </div>
    ¡Tus mensajes han sido recargados! Tienes disponibles ${maxMessagesPerDay} mensajes nuevamente. ¡Sigamos conversando!
    <div class="timestamp">Ahora</div>
  `;
  chat.appendChild(rechargeMessage);
  chat.scrollTop = chat.scrollHeight; 
  // Eliminar la alerta de límite si existe
  const limitAlert = document.querySelector('.message-limit-alert');
  if (limitAlert) {
    limitAlert.remove();
  }
}
// Modificación del evento de envío del formulario para comprobar límite
const originalFormSubmitListener = form.onsubmit;
form.addEventListener('submit', function(e) {
  // Si no hay mensajes restantes, prevenir envío
  if (remainingMessages <= 0) {
    e.preventDefault();
    // Mostrar mensaje de error
    const errorSound = new Audio('https://cdn.pixabay.com/download/audio/2022/03/15/audio_c8c8a73467.mp3?filename=error-126627.mp3');
    errorSound.volume = 0.3;
    errorSound.play().catch(err => console.log('Audio error:', err));
    // Resaltar el contador con una animación
    messageCounterElement.classList.add('depleted');
    messageCounterElement.style.animation = 'none';
    setTimeout(() => {
      messageCounterElement.style.animation = 'pulse 0.5s 3';
    }, 10);
    return false;
  }
  // Si hay mensajes disponibles, decrementar el contador
  decrementMessageCount();
});
// Inicializar el sistema de límite de mensajes cuando se carga la página
document.addEventListener('DOMContentLoaded', function() {
  // Cargar el sistema de límite de mensajes después de las otras inicializaciones
  setTimeout(initMessageLimitSystem, 100);
});
         </script>
</body>
</html>